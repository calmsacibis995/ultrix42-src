/*	@(#)ncform.h	1.2		11/7/83	*/
/************************************************************************
 *									*
 *			Copyright (c) 1983 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/************************************************************************
 *
 *			Modification History
 *
 *	Stephen Reilly, 07-Nov-83:
 * 001-	Because of the binary kit restrictions ncform can no longer be
 *	read in.  It is now a data structure that will be used to create
 *	the C version of the lexical analy.
 *
 ***********************************************************************/

char *ncformlin[] = {
"/*	ncform	4.1	83/08/11	*/\n",
"\n",
"int yylineno =1;\n",
"# define YYU(x) x\n",
"# define NLSTATE yyprevious=YYNEWLINE\n",
"char yytext[YYLMAX];\n",
"struct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;\n",
"char yysbuf[YYLMAX];\n",
"char *yysptr = yysbuf;\n",
"int *yyfnd;\n",
"extern struct yysvf *yyestate;\n",
"int yyprevious = YYNEWLINE;\n",
"yylook(){\n",
"	register struct yysvf *yystate, **lsp;\n",
"	register struct yywork *yyt;\n",
"	struct yysvf *yyz;\n",
"	int yych;\n",
"	struct yywork *yyr;\n",
"# ifdef LEXDEBUG\n",
"	int debug;\n",
"# endif\n",
"	char *yylastch;\n",
"	/* start off machines */\n",
"# ifdef LEXDEBUG\n",
"	debug = 0;\n",
"# endif\n",
"	if (!yymorfg)\n",
"		yylastch = yytext;\n",
"	else {\n",
"		yymorfg=0;\n",
"		yylastch = yytext+yyleng;\n",
"		}\n",
"	for(;;){\n",
"		lsp = yylstate;\n",
"		yyestate = yystate = yybgin;\n",
"		if (yyprevious==YYNEWLINE) yystate++;\n",
"		for (;;){\n",
"# ifdef LEXDEBUG\n",
"			if(debug)fprintf(yyout,\"state %d\\n\",yystate-yysvec-1);\n",
"# endif\n",
"			yyt = yystate->yystoff;\n",
"			if(yyt == yycrank){		/* may not be any transitions */\n",
"				yyz = yystate->yyother;\n",
"				if(yyz == 0)break;\n",
"				if(yyz->yystoff == yycrank)break;\n",
"				}\n",
"			*yylastch++ = yych = input();\n",
"		tryagain:\n",
"# ifdef LEXDEBUG\n",
"			if(debug){\n",
"				fprintf(yyout,\"unsigned char \");\n",
"				allprint(yych);\n",
"				putchar('\\n');\n",
"				}\n",
"# endif\n",
"			yyr = yyt;\n",
"			if ( (int)yyt > (int)yycrank){\n",
"				yyt = yyr + yych;\n",
"				if (yyt <= yytop && yyt->verify+yysvec == yystate){\n",
"					if(yyt->advance+yysvec == YYLERR)	/* error transitions */\n",
"						{unput(*--yylastch);break;}\n",
"					*lsp++ = yystate = yyt->advance+yysvec;\n",
"					goto contin;\n",
"					}\n",
"				}\n",
"# ifdef YYOPTIM\n",
"			else if((int)yyt < (int)yycrank) {		/* r < yycrank */\n",
"				yyt = yyr = yycrank+(yycrank-yyt);\n",
"# ifdef LEXDEBUG\n",
"				if(debug)fprintf(yyout,\"compressed state\\n\");\n",
"# endif\n",
"				yyt = yyt + yych;\n",
"				if(yyt <= yytop && yyt->verify+yysvec == yystate){\n",
"					if(yyt->advance+yysvec == YYLERR)	/* error transitions */\n",
"						{unput(*--yylastch);break;}\n",
"					*lsp++ = yystate = yyt->advance+yysvec;\n",
"					goto contin;\n",
"					}\n",
"				yyt = yyr + YYU(yymatch[yych]);\n",
"# ifdef LEXDEBUG\n",
"				if(debug){\n",
"					fprintf(yyout,\"try fall back character \");\n",
"					allprint(YYU(yymatch[yych]));\n",
"					putchar('\\n');\n",
"					}\n",
"# endif\n",
"				if(yyt <= yytop && yyt->verify+yysvec == yystate){\n",
"					if(yyt->advance+yysvec == YYLERR)	/* error transition */\n",
"						{unput(*--yylastch);break;}\n",
"					*lsp++ = yystate = yyt->advance+yysvec;\n",
"					goto contin;\n",
"					}\n",
"				}\n",
"			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){\n",
"# ifdef LEXDEBUG\n",
"				if(debug)fprintf(yyout,\"fall back to state %d\\n\",yystate-yysvec-1);\n",
"# endif\n",
"				goto tryagain;\n",
"				}\n",
"# endif\n",
"			else\n",
"				{unput(*--yylastch);break;}\n",
"		contin:\n",
"# ifdef LEXDEBUG\n",
"			if(debug){\n",
"				fprintf(yyout,\"state %d char \",yystate-yysvec-1);\n",
"				allprint(yych);\n",
"				putchar('\\n');\n",
"				}\n",
"# endif\n",
"			;\n",
"			}\n",
"# ifdef LEXDEBUG\n",
"		if(debug){\n",
"			fprintf(yyout,\"stopped at %d with \",*(lsp-1)-yysvec-1);\n",
"			allprint(yych);\n",
"			putchar('\\n');\n",
"			}\n",
"# endif\n",
"		while (lsp-- > yylstate){\n",
"			*yylastch-- = 0;\n",
"			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){\n",
"				yyolsp = lsp;\n",
"				if(yyextra[*yyfnd]){		/* must backup */\n",
"					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){\n",
"						lsp--;\n",
"						unput(*yylastch--);\n",
"						}\n",
"					}\n",
"				yyprevious = YYU(*yylastch);\n",
"				yylsp = lsp;\n",
"				yyleng = yylastch-yytext+1;\n",
"				yytext[yyleng] = 0;\n",
"# ifdef LEXDEBUG\n",
"				if(debug){\n",
"					fprintf(yyout,\"\\nmatch \");\n",
"					sprint(yytext);\n",
"					fprintf(yyout,\" action %d\\n\",*yyfnd);\n",
"					}\n",
"# endif\n",
"				return(*yyfnd++);\n",
"				}\n",
"			unput(*yylastch);\n",
"			}\n",
"		if (yytext[0] == 0  /* && feof(yyin) */)\n",
"			{\n",
"			yysptr=yysbuf;\n",
"			return(0);\n",
"			}\n",
"		yyprevious = yytext[0] = input();\n",
"		if (yyprevious>0)\n",
"			output(yyprevious);\n",
"		yylastch=yytext;\n",
"# ifdef LEXDEBUG\n",
"		if(debug)putchar('\\n');\n",
"# endif\n",
"		}\n",
"	}\n",
"yyback(p, m)\n",
"	int *p;\n",
"{\n",
"if (p==0) return(0);\n",
"while (*p)\n",
"	{\n",
"	if (*p++ == m)\n",
"		return(1);\n",
"	}\n",
"return(0);\n",
"}\n",
"	/* the following are only used in the lex library */\n",
"yyinput(){\n",
"	return(input());\n",
"	}\n",
"yyoutput(c)\n",
"  int c; {\n",
"	output(c);\n",
"	}\n",
"yyunput(c)\n",
"   int c; {\n",
"	unput(c);\n",
"	}\n",
0 };
