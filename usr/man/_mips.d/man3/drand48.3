.\" SCCSID: @(#)drand48.3	8.1	9/11/90
.if n .ll 79
.TH drand48 3 
.EQ
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft 1
.ps \n(99
.ft \n(98
.EN
.SH Name
drand48, erand48, lrand48, nrand48, mrand48, jrand48, srand48, seed48, lcong48 \- generate uniformly distributed pseudo-random numbers
.SH Syntax
.nf
.B double drand48 ( )
.PP
.B double erand48 (xsubi)
.B unsigned short xsubi[3];
.PP
.B long lrand48 ( )
.PP
.B long nrand48 (xsubi)
.B unsigned short xsubi[3];
.PP
.B long mrand48 ( )
.PP
.B long jrand48 (xsubi)
.B unsigned short xsubi[3];
.PP
.B void srand48 (seedval)
.B long seedval;
.PP
.B unsigned short \(**seed48 (seed16v)
.B unsigned short seed16v[3];
.PP
.B void lcong48 (param)
.B unsigned short param[7];
.SH Description
.NXR "drand48 subroutine"
.NXR "erand48 subroutine"
.NXR "lrand48 subroutine"
.NXR "nrand48 subroutine"
.NXR "mrand48 subroutine"
.NXR "jrand48 subroutine"
.NXR "srand48 subroutine"
.NXR "seed48 subroutine"
.NXR "lcong48 subroutine"
.NXR "pseudorandom number" "generating"
.NXA "random number" "pseudorandom number"
.if t .ig
.NT
NOTE: Your terminal may not be able to accurately display 
the special math symbols in this reference page. See the 
.I ULTRIX Programmer's Manual, Unsupported
for a complete description of the math symbols. 
.NE
..
.PP
This family of functions generates pseudo-random numbers using the
well-known linear congruential algorithm and 48-bit integer arithmetic.
.PP
Functions
.PN drand48
and
.PN erand48
return non-negative double-precision floating-point values
uniformly distributed over the 
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "interval 
.ps 10
.ft 1
.ds 12 "\f1[\fP\|\f10\fP\f1.\fP\|\f10\fP\|\f1,\fP
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\f11\fP\f1.\fP\|\f10\fP\|\f1)\fP\f1.\fP
.as 12 "\|\*(13
.ds 12 \x'0'\f1\s10\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.PP
Functions
.PN lrand48
and
.PN nrand48
return non-negative long integers uniformly distributed over the
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.as 11 "interval 
.ps 10
.ft 1
.ds 12 "\f1[\fP\|\f10\fP\|\f1,\fP
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\f12\fP
.ds 14 "\f13\fP\|\f11\fP
.as 13 \v'-20u'\*(14\v'20u'
.as 12 "\|\*(13
.ds 13 "\f1)\fP\f1.\fP
.as 12 "\|\*(13
.ds 12 \x'0'\f1\s10\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.PP
Functions
.PN mrand48
and
.PN jrand48
return signed long integers uniformly distributed
.br
.sp 2p
over the interval
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 10
.ft 1
.ds 12 "\f1[\fP\|\(mi\|\f12\fP
.ds 13 "\f13\fP\|\f11\fP
.as 12 \v'-20u'\*(13\v'20u'
.ds 13 "\f1,\fP
.as 12 "\|\*(13
.ds 13 "\ 
.as 12 "\|\*(13
.ds 13 "\f12\fP
.ds 14 "\f13\fP\|\f11\fP
.as 13 \v'-20u'\*(14\v'20u'
.as 12 "\|\*(13
.ds 13 "\f1)\fP\f1.\fP
.as 12 "\|\*(13
.ds 12 \x'0'\f1\s10\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 "
.ps \n(99
.ft \n(98
\*(11
.PP
Functions
.PN srand48,
.PN seed48
and
.PN lcong48
are initialization entry points, one of which should be invoked before
either
.PN drand48,
.PN lrand48
or
.PN mrand48
is called.
Although it is not recommended practice,
constant default initializer values will be supplied automatically if
.PN drand48,
.PN lrand48
or
.PN mrand48
is called without a prior call to an initialization entry point.
Functions
.PN erand48,
.PN nrand48
and
.PN jrand48
do not require an initialization entry point to be called first.
.PP
All the routines work by generating a sequence of 48-bit integer values,
.nr 99 \n(.s
.nr 98 \n(.f
.rm 11 
.ps 10
.ft 1
.ds 12 "X
.ds 13 "i
.as 12 \v'20u'\*(13\v'-20u'
.ds 13 "\f1,\fP
.as 12 "\|\*(13
.ds 12 \x'0'\f1\s10\*(12\|\s\n(99\f\n(98
.as 11 \*(12
.ps \n(99
.ft \n(98
.as 11 " according to the linear congruential formula
.ps \n(99
.ft \n(98
\*(11
.PP
.ce
.EQ I
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft 1
.ds 11 "X
.ds 12 "n\|\(pl\|\f11\fP
.as 11 \v'20u'\*(12\v'-20u'
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\(eq
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\f1(\fPaX
.ds 13 "n
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 12 "\|
.as 11 "\|\*(12
.ds 12 "\(pl
.as 11 "\|\*(12
.ds 12 "\|
.as 11 "\|\*(12
.ds 12 "c\|\f1)\fP
.ft 1
.ds 13 "mod
.ds 13 \f1\*(13\f1
.ft 1
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "m
.as 13 "\|\*(14
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "n\|\(>=\|\f10\fP\f1.\fP
.as 11 "\|\*(12
.ds 11 \x'0'\f1\s10\*(11\|\s\n(99\f\n(98
.nr 11 \w'\*(11'
.nr MK 0
.if 60>\n(.v .ne 60u
.rn 11 10
\*(10
.ps \n(99
.ft \n(98
.EN
.PP
.sp 3p
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The parameter 
.ps 10
.ft 1
.ds 13 "m
.ds 14 "\|
.as 13 "\|\*(14
.ds 14 "\(eq
.as 13 "\|\*(14
.ds 14 "\|
.as 13 "\|\*(14
.ds 14 "\f12\fP
.ds 15 "\f14\fP\|\f18\fP
.as 14 \v'-20u'\*(15\v'20u'
.as 13 "\|\*(14
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "; hence 48-bit integer arithmetic is
.ps \n(99
.ft \n(98
\*(12
performed.
Unless
.PN lcong48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "has been invoked, the multiplier value 
.ps 10
.ft 1
.ds 13 "a
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and the addend value 
.ps 10
.ft 1
.ds 13 "c
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
are given by
.PP
.RS 6
.EQ I
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft 1
.ds 11 "a
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\(eq
.ds 12 \k(97\*(12
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ft 1
.ds 12 "\f15\fPDEECE\|\f16\fP\|\f16\fPD
.ds 12 \f1\*(12\f1
.ft 1
.as 11 "\|\*(12
.ds 12 "\|
.ds 13 "\f11\fP\|\f16\fP
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\(eq
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ft 1
.ds 12 "\f12\fP\|\f17\fP\|\f13\fP\|\f16\fP\|\f17\fP\|\f13\fP\|\f11\fP\|\f16\fP\|\f13\fP\|\f11\fP\|\f15\fP\|\f15\fP
.ds 12 \f1\*(12\f1
.ft 1
.as 11 "\|\*(12
.ds 12 "\|
.ds 13 "\f18\fP
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 11 \x'0'\f1\s10\*(11\|\s\n(99\f\n(98
.nr 11 \w'\*(11'
.nr MK 1
.if 60>\n(.v .ne 60u
.rn 11 10
\*(10
.ps \n(99
.ft \n(98
.EN
.br
.EQ I
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft 1
.ds 11 "c
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\(eq
.nr 11 \w'\s10\*(11\|'
.ds 11 \h'|\n(97u-\n(11u'\*(11
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ft 1
.ds 12 "B
.ds 12 \f1\*(12\f1
.ft 1
.as 11 "\|\*(12
.ds 12 "\|
.ds 13 "\f11\fP\|\f16\fP
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ds 12 "\(eq
.as 11 "\|\*(12
.ds 12 "\ 
.as 11 "\|\*(12
.ft 1
.ds 12 "\f11\fP\|\f13\fP
.ds 12 \f1\*(12\f1
.ft 1
.as 11 "\|\*(12
.ds 12 "\|
.ds 13 "\f18\fP
.as 12 \v'20u'\*(13\v'-20u'
.as 11 "\|\*(12
.ds 12 ".
.as 11 "\*(12
.ds 11 \x'0'\f1\s10\*(11\s\n(99\f\n(98
.nr 11 \w'\*(11'
.nr MK 1
.if 60>\n(.v .ne 60u
.rn 11 10
\*(10
.ps \n(99
.ft \n(98
.EN
.RE
.PP
The value returned by any of the functions
.PN drand48, 
.PN erand48, 
.PN lrand48, 
.PN nrand48, 
.PN mrand48
or
.PN jrand48
is computed by first generating the next 48-bit
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " in the sequence.
.ps \n(99
.ft \n(98
\*(12
Then the appropriate number of bits, according to the type of data item
to be returned, are copied
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "from the high-order (leftmost) bits of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
and transformed into the returned value.
.PP
The functions
.PN drand48,
.PN lrand48
and
.PN mrand48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "store the last 48-bit 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " generated in an internal buffer;
.ps \n(99
.ft \n(98
\*(12
that is why they must be initialized prior to being invoked.
The functions
.PN erand48,
.PN nrand48
and
.PN jrand48
require the calling program to provide storage for the
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "successive 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " values in the array
.ps \n(99
.ft \n(98
\*(12
specified as an argument when the functions are invoked.
That is why these routines do not have to be initialized. 
The calling program merely has to place
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "the desired initial value of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " into the
.ps \n(99
.ft \n(98
\*(12
array and pass it as an argument.
By using different
arguments, functions
.PN erand48,
.PN nrand48
and
.PN jrand48
allow separate modules of a large program to generate several
.I independent\^
streams of pseudo-random numbers.  That is, the sequence of numbers
in each stream will
not depend upon how many times the routines have been called to generate
numbers for the other streams.
.PP
The initializer function
.PN srand48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "sets the high-order 32 bits of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " to the 32 bits contained in
.ps \n(99
.ft \n(98
\*(12
its argument.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "The low-order 16 bits of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " are set to the arbitrary value
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 10
.ft 1
.ft 1
.ds 13 "\f13\fP\|\f13\fP\|\f10\fPE
.ds 13 \f1\*(13\f1
.ft 1
.ds 14 "\f11\fP\|\f16\fP
.as 13 \v'20u'\*(14\v'-20u'
.ds 14 ".
.as 13 "\*(14
.ds 13 \x'0'\f1\s10\*(13\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.PP
The initializer function
.PN seed48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "sets the value of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " to the 48-bit value specified in the
.ps \n(99
.ft \n(98
\*(12
argument array.
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "In addition, the previous value of 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " is copied into a 48-bit
.ps \n(99
.ft \n(98
\*(12
internal buffer, used only by
.PN seed48,
and a pointer to this buffer is the value returned by
.PN seed48.
This returned pointer,
which can just be ignored if not needed, is useful
if a program is to be restarted from a given point at some future time
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "\(em use the pointer to get at and store the last 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " value, and
.ps \n(99
.ft \n(98
\*(12
then use this value to reinitialize via
.PN seed48
when the program is restarted.
.PP
The initialization function
.PN lcong48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "allows the user to specify the initial 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 14 "\f1,\fP
.as 13 "\|\*(14
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " the multiplier value
.ps \n(99
.ft \n(98
\*(12
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.ps 10
.ft 1
.ds 13 "a\|\f1,\fP
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and the addend value 
.ps 10
.ft 1
.ds 13 "c\f1.\fP
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
Argument array elements
.I param[0-2]\^
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "specify 
.ps 10
.ft 1
.ds 13 "X
.ds 14 "i
.as 13 \v'20u'\*(14\v'-20u'
.ds 14 "\f1,\fP
.as 13 "\|\*(14
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.I param[3-5]\^
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "specify the multiplier 
.ps 10
.ft 1
.ds 13 "a\|\f1,\fP
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and
.ps \n(99
.ft \n(98
\*(12
.I param[6]\^
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "specifies the 16-bit addend 
.ps 10
.ft 1
.ds 13 "c\f1.\fP
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
After
.PN lcong48
has been called, a subsequent call to either
.PN srand48
or
.PN seed48
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "will restore the ``standard'' multiplier and addend values, 
.ps 10
.ft 1
.ds 13 "a
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 " and 
.ps 10
.ft 1
.ds 13 "c\|\f1,\fP
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
specified on the previous page.
.SH Notes
The source code for the portable version can even be used on computers
which do not have floating-point arithmetic.  In such a situation,
functions
.PN drand48 
and
.PN erand48
do not exist.  Instead, they are replaced
by the two new functions below.
.PP
.nf
.B long irand48 (m)
.B unsigned short m;
.PP
.B long krand48 (xsubi, m)
.B unsigned short xsubi[3], m;
.fi
.PP
Functions 
.PN irand48 
and
.PN krand48
return non-negative long integers uniformly distributed over the
.nr 99 \n(.s
.nr 98 \n(.f
.rm 12 
.as 12 "interval 
.ps 10
.ft 1
.ds 13 "\f1[\fP\|\f10\fP\|\f1,\fP
.ds 14 "\ 
.as 13 "\|\*(14
.ds 14 "m\|\(mi\|\f11\fP
.as 13 "\|\*(14
.ds 14 "\f1]\fP\f1.\fP
.as 13 "\|\*(14
.ds 13 \x'0'\f1\s10\*(13\|\s\n(99\f\n(98
.as 12 \*(13
.ps \n(99
.ft \n(98
.as 12 "
.ps \n(99
.ft \n(98
\*(12
.SH See Also
rand(3)
.br
.I ULTRIX Programmer's Manual, Unsupported
