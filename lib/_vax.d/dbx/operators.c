/*@(#)operators.c	4.2	Ultrix	11/9/90*/

/************************************************************************
 *									*
 *			Copyright (1986 by				*
 *		Digital Equipment Corporation, Maynard, MA		*
 *			All rights reserved.				*
 *									*
 *   This software is furnished under a license and may be used and	*
 *   copied  only  in accordance with the terms of such license and	*
 *   with the  inclusion  of  the  above  copyright  notice.   This	*
 *   software  or  any  other copies thereof may not be provided or	*
 *   otherwise made available to any other person.  No title to and	*
 *   ownership of the software is hereby transferred.			*
 *									*
 *   This software is  derived  from  software  received  from  the	*
 *   University    of   California,   Berkeley,   and   from   Bell	*
 *   Laboratories.  Use, duplication, or disclosure is  subject  to	*
 *   restrictions  under  license  agreements  with  University  of	*
 *   California and with AT&T.						*
 *									*
 *   The information in this software is subject to change  without	*
 *   notice  and should not be construed as a commitment by Digital	*
 *   Equipment Corporation.						*
 *									*
 *   Digital assumes no responsibility for the use  or  reliability	*
 *   of its software on equipment which is not supplied by Digital.	*
 *									*
 ************************************************************************/

/************************************************************************
 *									*
 *			Modification History				*
 *									*
 *  003	- Added support for vectors.							*
 *		  (L Miller, 18JAN90)									*
 *									*
 *	002 - Merged in 4.3 changes.					*
 *	      (vjh, April 29, 1986)					*
 *									*
 *	001 - Added new op O_PRINTENTRY.  				*
 *	      (Victoria Holt, July 18, 1985)				*
 *									*
 ************************************************************************/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
static char sccsid[] = "@(#)operators.c	5.1 (Berkeley) 5/31/85";
#endif not lint

static char rcsid[] = "$Header: operators.c,v 1.5 84/12/26 10:41:01 linton Exp $";

/*
 * Tree node classes.
 */

#include "defs.h"
#include "operators.h"

/* there was a good chance that adding an operator could cause problems 
 * to simplify the process the opinfo array is now generated by code
 * rather than by data initialization. you simply add the operator to
 * the list of enumerated types and then add an init_opinfo() macro to the
 * subroutine OpInit(). since the macro is keyed on the enum type, the order
 * is no longer critical. be sure that all modules that use the operators
 * are recompiled.
 */

#ifndef public
typedef struct {
    char numargs;
    char opflags;
    String opstring;
} Opinfo;

typedef enum {
    O_NOP,
    O_NAME, O_SYM, O_LCON, O_CCON, O_FCON, O_SCON,
    O_RVAL, O_VREG, O_INDEX, O_INDIR, O_DOT,
    O_COMMA,

    O_ITOF, O_ADD, O_ADDF, O_SUB, O_SUBF, O_NEG, O_NEGF,
    O_MUL, O_MULF, O_DIVF, O_DIV, O_MOD,

    O_AND, O_OR,

    O_LT, O_LTF, O_LE, O_LEF, O_GT, O_GTF, O_GE, O_GEF,
    O_EQ, O_EQF, O_NE, O_NEF,

    O_ALIAS,		/* rename a command */
    O_ASSIGN,		/* assign a value to a program variable */
    O_CALL,		/* call a procedure in the program */
    O_CATCH,		/* catch a signal before program does */
	O_CD,           /* do a change dir for the user */
    O_CHFILE,		/* change (or print) the current source file */
    O_CONT,		/* continue execution */
    O_DEBUG,		/* invoke a dbx internal debugging routine */
    O_DELETE,		/* remove a trace/stop */
    O_DUMP,		/* dump out variables */
    O_EDIT,		/* edit a file (or function) */
	O_FMASK,	/* print vector registers with FALSE mask */
    O_FUNC,		/* set the current function */
    O_GRIPE,		/* send mail to debugger support person */
	O_GETENV,   /* get a variable form the enviornment */
    O_HELP,		/* print a synopsis of debugger commands */
    O_IGNORE,		/* let program catch signal */
    O_LIST,		/* list source lines */
    O_PRINT,		/* print the values of a list of expressions */
    O_PRINTF,		/* print the values of a list of expressions formatted 
							(lang dep.)*/
    O_PSYM,		/* print symbol information */
	O_PWD,      /* print current working dir */
	O_RECORD,   /* record input in file */
    O_RUN,		/* start up program */
    O_SKIP,		/* skip the current line */
    O_SOURCE,		/* read commands from a file */
    O_STATUS,		/* display currently active trace/stop's */
    O_STEP,		/* execute a single line */
    O_STEPV,		/* execute to the next selected vector instruction */
    O_STOP,		/* stop on an event */
    O_STOPI,		/* stop on an event at an instruction boundary */
	O_TMASK,	/* print vector registers with TRUE mask */
    O_TRACE,		/* trace something on an event */
    O_TRACEI,		/* trace at the instruction level */
    O_WHATIS,		/* print the declaration of a variable */
    O_WHERE,		/* print a stack trace */
    O_WHEREIS,		/* print all the symbols with the given name */
    O_WHICH,		/* print out full qualification of a symbol */
    O_EXAMINE,		/* examine program instructions/data */

    O_ADDEVENT,		/* add an event */
    O_ENDX,		/* end of program reached */
    O_IF,		/* if first arg is true, do commands in second arg */
    O_ONCE,		/* add a "one-time" event, delete when reached */
    O_PRINTCALL,	/* print out the current procedure and arguments */
    O_PRINTENTRY,	/* print out current proc. without args. */
    O_PRINTIFCHANGED,	/* print the value of the argument if it changed */
    O_PRINTRTN,		/* print out the routine & value that just returned */
    O_PRINTSRCPOS,	/* print out the current source position */
    O_PROCRTN,		/* call completed */
    O_QLINE,		/* filename, line number */
    O_STOPIFCHANGED,	/* stop if the value of the argument has changed */
    O_STOPX,		/* stop execution */
    O_TRACEON,		/* begin tracing source line, variable, or all lines */
    O_TRACEOFF,		/* end tracing source line, variable, or all lines */

    O_TYPERENAME,	/* state the type of an expression */
    O_REREAD,		/* re-run program with the same arguments as before */
					/* but, force the object file to be reread */
    O_RERUN,		/* re-run program with the same arguments as before */
    O_RETURN,		/* continue execution until procedure returns */
    O_UP,		/* move current function up the call stack */
    O_DOWN,		/* move current function down the call stack */
    O_CALLPROC,		/* call command */
    O_SEARCH,		/* regular expression pattern search through source */
    O_SET,		/* set a debugger variable */
	O_SETENV,    /* set an enivornment variable */
    O_UNSET,		/* unset a debugger variable */
    O_UNALIAS,		/* remove an alias */

	O_LASTOP
} Operator;

/*
 * Operator flags and predicates.
 */

#define null 0
#define LEAF 01
#define UNARY 02
#define BINARY 04
#define BOOL 010
#define REALOP 020
#define INTOP 040

#define isbitset(a, m)	((a&m) == m)
#define isleaf(o)	isbitset(opinfo[ord(o)].opflags, LEAF)
#define isunary(o)	isbitset(opinfo[ord(o)].opflags, UNARY)
#define isbinary(o)	isbitset(opinfo[ord(o)].opflags, BINARY)
#define isreal(o)	isbitset(opinfo[ord(o)].opflags, REALOP)
#define isint(o)	isbitset(opinfo[ord(o)].opflags, INTOP)
#define isboolean(o)	isbitset(opinfo[ord(o)].opflags, BOOL)

#define degree(o)	(opinfo[ord(o)].opflags&(LEAF|UNARY|BINARY))
#define nargs(o)	(opinfo[ord(o)].numargs)

#endif

/*
 * Operator information structure.
 */

#define init_opinfo(oper, Numargs, Flags, Name)  		\
				 opinfo[ord(oper)].numargs = Numargs; 		\
				 opinfo[ord(oper)].opflags = Flags;   		\
				  if(Name != 0) {                    		\
					if(opinfo[ord(oper)].opstring == 0)            \
						opinfo[ord(oper)].opstring = newarr(char, 25); \
					strcpy(opinfo[ord(oper)].opstring, Name);\
				  } else									\
				 	opinfo[ord(oper)].opstring = Name;
				

public Opinfo opinfo[O_LASTOP];

public OpInit ()
{
	init_opinfo(O_NOP, 			0,  null, 		0);
	init_opinfo(O_NAME,			-1,	LEAF, 		0);
	init_opinfo(O_SYM,			-1,	LEAF,		0);
	init_opinfo(O_LCON,			-1,	LEAF,		0);
	init_opinfo(O_CCON,			-1,	LEAF,		0);
	init_opinfo(O_FCON,			-1,	LEAF,		0);
	init_opinfo(O_SCON,			-1,	LEAF,		0);
	init_opinfo(O_RVAL,			1,	UNARY,		0);
	init_opinfo(O_VREG,			1,	LEAF,		0);
	init_opinfo(O_INDEX,		2,	null,		0);
	init_opinfo(O_INDIR,		1,	UNARY,		"^");
	init_opinfo(O_DOT,			2,	null,		".");
	init_opinfo(O_COMMA,		2,	null,		",");
	init_opinfo(O_ITOF,			1,	UNARY|INTOP,	0);
	init_opinfo(O_ADD,			2,	BINARY|INTOP,	"+");
	init_opinfo(O_ADDF,			2,	BINARY|REALOP,	"+");
	init_opinfo(O_SUB,			2,	BINARY|INTOP,	"-");
	init_opinfo(O_SUBF,			2,	BINARY|REALOP,	"-");
	init_opinfo(O_NEG,			1,	UNARY|INTOP,	"-");
	init_opinfo(O_NEGF,			1,	UNARY|REALOP,	"-");
	init_opinfo(O_MUL,			2,	BINARY|INTOP,	"*");
	init_opinfo(O_MULF,			2,	BINARY|REALOP,	"*");
	init_opinfo(O_DIVF,			2,	BINARY|REALOP,	"/");
	init_opinfo(O_DIV,			2,	BINARY|INTOP,	" div ");
	init_opinfo(O_MOD,			2,	BINARY|INTOP,	" mod ");
	init_opinfo(O_AND,			2,	BINARY|INTOP,	" and ");
	init_opinfo(O_OR,			2,	BINARY|INTOP,	" or ");
	init_opinfo(O_LT,			2,	BINARY|INTOP,	" < ");
	init_opinfo(O_LTF,			2,	BINARY|REALOP,	" < ");
	init_opinfo(O_LE,			2,	BINARY|INTOP,	" <= ");
	init_opinfo(O_LEF,			2,	BINARY|REALOP,	" <= ");
	init_opinfo(O_GT,			2,	BINARY|INTOP,	" > ");
	init_opinfo(O_GTF,			2,	BINARY|REALOP,	" > ");
	init_opinfo(O_GE,			2,	BINARY|INTOP,	" >= ");
	init_opinfo(O_GEF,			2,	BINARY|REALOP,	" >= ");
	init_opinfo(O_EQ,			2,	BINARY|INTOP,	" = ");
	init_opinfo(O_EQF,			2,	BINARY|REALOP,	" = ");
	init_opinfo(O_NE,			2,	BINARY|INTOP,	" <> ");
	init_opinfo(O_NEF,			2,	BINARY|REALOP,	" <> ");
	
	init_opinfo(O_ALIAS,		2,	null,		"alias");
	init_opinfo(O_ASSIGN,		2,	null,		" := ");
	init_opinfo(O_CALL,			2,	null,		"call");
	init_opinfo(O_CATCH,		0,	null,		"catch");
	init_opinfo(O_CD,       	1,  null,       "cd"); 
	init_opinfo(O_CHFILE,		0,	null,		"file");
	init_opinfo(O_CONT,			0,	null,		"cont");
	init_opinfo(O_DEBUG,		0,	null,		"debug");
	init_opinfo(O_DELETE,		1,	null,		"delete");
	init_opinfo(O_DUMP,			1,	null,		"dump");
	init_opinfo(O_EDIT,			0,	null,		"edit");
	init_opinfo(O_FMASK,		2,	null,		"fmask");
	init_opinfo(O_FUNC,			1,	null,		"func");
	init_opinfo(O_GRIPE,		0,	null,		"gripe");
	init_opinfo(O_GETENV,      	1,  null,		"getenv"); 
	init_opinfo(O_HELP,			0,	null,		"help");
	init_opinfo(O_IGNORE,		0,	null,		"ignore");
	init_opinfo(O_LIST,			2,	null,		"list");
	init_opinfo(O_PRINT,		1,	null,		"print");
	init_opinfo(O_PRINTF,		2,	null,		"printf");
	init_opinfo(O_PSYM,			1,	null,		"psym");
	init_opinfo(O_PWD,        	0,  null,       "pwd");
	init_opinfo(O_RECORD,      	1,  null,       "record");
	init_opinfo(O_RUN,			0,	null,		"run");
	init_opinfo(O_SKIP,			0,	null,		"skip");
	init_opinfo(O_SOURCE,		0,	null,		"source");
	init_opinfo(O_STATUS,		0,	null,		"status");
	init_opinfo(O_STEP,			0,	null,		"step");
	init_opinfo(O_STEPV,		0,	null,		"stepv");
	init_opinfo(O_STOP,			3,	null,		"stop");
	init_opinfo(O_STOPI,		3,	null,		"stopi");
	init_opinfo(O_TMASK,		2,	null,		"tmask");
	init_opinfo(O_TRACE,		3,	null,		"trace");
	init_opinfo(O_TRACEI,		3,	null,		"tracei");
	init_opinfo(O_WHATIS,		1,	null,		"whatis");
	init_opinfo(O_WHERE,		0,	null,		"where");
	init_opinfo(O_WHEREIS,		1,	null,		"whereis");
	init_opinfo(O_WHICH,		1,	null,		"which");
	init_opinfo(O_EXAMINE,		0,	null,		"examine");
	init_opinfo(O_ADDEVENT,		0,	null,		"when");
	init_opinfo(O_ENDX,			0,	null,		nil);
	init_opinfo(O_IF,			0,	null,		"if");
	init_opinfo(O_ONCE,			0,	null,		"once");
	init_opinfo(O_PRINTCALL,	1,	null,		"printcall");
	init_opinfo(O_PRINTENTRY,	0,	null,		"printentry");
	init_opinfo(O_PRINTIFCHANGED,	1,	null,		"printifchanged");
	init_opinfo(O_PRINTRTN,		1,	null,		"printrtn");
	init_opinfo(O_PRINTSRCPOS,	1,	null,		"printsrcpos");
	init_opinfo(O_PROCRTN,		1,	null,		"procrtn");
	init_opinfo(O_QLINE,		2,	null,		nil);
	init_opinfo(O_STOPIFCHANGED,	1,	null,		"stopifchanged");
	init_opinfo(O_STOPX,		0,	null,		"stop");
	init_opinfo(O_TRACEON,		1,	null,		"traceon");
	init_opinfo(O_TRACEOFF,		1,	null,		"traceoff");
	init_opinfo(O_TYPERENAME,	2,	UNARY,		"type rename");
	init_opinfo(O_REREAD,		0,	null,		"reread");
	init_opinfo(O_RERUN,		0,	null,		"rerun");
	init_opinfo(O_RETURN,		1,	null,		"return");
	init_opinfo(O_UP,			1,	UNARY,		"up");
	init_opinfo(O_DOWN,			1,	UNARY,		"down");
	init_opinfo(O_CALLPROC,		3,	null,		"call");
	init_opinfo(O_SEARCH,		2,	null,		"search");
	init_opinfo(O_SET,			2,	null,		"set");
	init_opinfo(O_SETENV,		2,	null,		"setenv");
	init_opinfo(O_UNSET,		1,	null,		"unset");
	init_opinfo(O_UNALIAS,		1,	null,		"unalias");
}
